Explanation
Say we have the decimal representation of "Hello World" as "72 101 108 108 111 32 87 111 114 108 100 33" this repository is for recovering the plaintext when spacing has been removed e.g. "72101108108111328711111410810033". In both the decimal and octal case the original plaintext can be uniquely recovered. If we define a sliding window of width 3 that decreases in size over the plaintext until it covers a valid (32<=value<127) span [e.g. 721 -> 72 for the first chunk then move the window to 101 for the second], then we never encounter a situation where the larger window picks up a false positive and misses the true smaller value. This is because for such a situation to occur the smaller value would need to be >=32 but any 3 digit larger window starting with 32 (32x) would be > 127 and thus not be valid.

However, this isn't the case for binary and the partial window bytes can be heavily degenerate. 4 different modes are offered to try to alleviate this where the window either traverses from the start -> end or end -> start, each with either starting the window with a width of 1 and increasing it (prioritising low bytes) or with a width of 7 (8 would never be valid) and decreasing it (prioritising high bytes). While none of these modes will fully recover the original plaintext each will likely get different parts of it, allowing it to be pieced together. The Javascript version also allows interactive selection of which valid byte to use one byte at a time.

Finally, printable hex will always have 2 digits and is only included for the case of an interrupted/imperfect ciphertext (e.g. instead of "48 65 6c 6c 6f" we have "48 65 6 6c 6f") where instead of the error in the middle throwing off the rest of the plaintext it's gracefully skipped over until another valid span is encountered.
